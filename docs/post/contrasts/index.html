<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Factors, dummy coding and contrasts | Stefano Coretta</title>

<meta name="keywords" content="statistics, rstats" />
<meta name="description" content="This post is an overview of how factors (i.e. categorical variables) are coded under the hood using dummy coding and which types of dummy coding can be set in R.1
Introduction There’s seems to be a bit of terminological mix-up in the wild, so we first present a terminological set that will be used throughout the vignette.
Categorical variables in R are generally stored using factors. A factor is a vector of values from a categorical variable.">
<meta name="author" content="Stefano Coretta">
<link rel="canonical" href="https://stefanocoretta.github.io/post/contrasts/" />
<link href="/assets/css/stylesheet.min.a31c75ee58abbdfa57a7c3ce443a8651fe82bb20fcdb7c710d6200a7094b5ce4.css" integrity="sha256-oxx17lirvfpXp8PORDqGUf6CuyD823xxDWIApwlLXOQ=" rel="preload stylesheet"
    as="style">

<link rel="icon" href="https://stefanocoretta.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://stefanocoretta.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://stefanocoretta.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://stefanocoretta.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://stefanocoretta.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.85.0" />


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>



<script src="https://kit.fontawesome.com/0019a3da9c.js" crossorigin="anonymous"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jpswalsh/academicons@1/css/academicons.min.css">


<link rel="preconnect" href="https://fonts.gstatic.com">
<link href="https://fonts.googleapis.com/css2?family=Alegreya+Sans+SC:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">


<link rel="stylesheet" href="/leaflet/leaflet.css"/>
<script src="/leaflet/leaflet.js"></script>
<link rel="stylesheet" href="/Leaflet.awesome-markers-2.0-develop/dist/leaflet.awesome-markers.css">
<script src="/Leaflet.awesome-markers-2.0-develop/dist/leaflet.awesome-markers.js"></script>
<meta property="og:title" content="Factors, dummy coding and contrasts" />
<meta property="og:description" content="This post is an overview of how factors (i.e. categorical variables) are coded under the hood using dummy coding and which types of dummy coding can be set in R.1
Introduction There’s seems to be a bit of terminological mix-up in the wild, so we first present a terminological set that will be used throughout the vignette.
Categorical variables in R are generally stored using factors. A factor is a vector of values from a categorical variable." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://stefanocoretta.github.io/post/contrasts/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-07-20T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2021-07-20T00:00:00&#43;00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Factors, dummy coding and contrasts"/>
<meta name="twitter:description" content="This post is an overview of how factors (i.e. categorical variables) are coded under the hood using dummy coding and which types of dummy coding can be set in R.1
Introduction There’s seems to be a bit of terminological mix-up in the wild, so we first present a terminological set that will be used throughout the vignette.
Categorical variables in R are generally stored using factors. A factor is a vector of values from a categorical variable."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://stefanocoretta.github.io/post/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Factors, dummy coding and contrasts",
      "item": "https://stefanocoretta.github.io/post/contrasts/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Factors, dummy coding and contrasts",
  "name": "Factors, dummy coding and contrasts",
  "description": "This post is an overview of how factors (i.e. categorical variables) are coded under the hood using dummy coding and which types of dummy coding can be set in R.1\nIntroduction There’s seems to be a bit of terminological mix-up in the wild, so we first present a terminological set that will be used throughout the vignette.\nCategorical variables in R are generally stored using factors. A factor is a vector of values from a categorical variable.",
  "keywords": [
    "statistics", "rstats"
  ],
  "articleBody": "  This post is an overview of how factors (i.e. categorical variables) are coded under the hood using dummy coding and which types of dummy coding can be set in R.1\nIntroduction There’s seems to be a bit of terminological mix-up in the wild, so we first present a terminological set that will be used throughout the vignette.\nCategorical variables in R are generally stored using factors. A factor is a vector of values from a categorical variable. The possible values in a factor are called levels in R.\nFor each observation in the factor, the vector specifies the level of that observation.\nFor example, let’s assume we have a data set with information on dinosaurs and one column specifies the dinosaur’s diet: carnivore, herbivore, omnivore.\nIn R, this column can be coded as a factor:\nfactor(c(\"carnivore\", \"carnivore\", \"herbivore\", \"omnivore\", \"herbivore\")) ## [1] carnivore carnivore herbivore omnivore herbivore ## Levels: carnivore herbivore omnivore We are so accustomed to using factors in regression models that sometimes we forget that regressions only work with numbers and cannot work with categorical variables.\nTo fit a regression model with categorical variables, these are first converted to numbers. The process of conversion is called dummy variable coding or simply dummy coding. This consists of assigning 0s or 1s to the levels in the variable.\nLet’s go through a simple example of dummy coding of a categorical variable with only 2 levels: metropolitan and rural.\nThe most simple way of coding this categorical variable as a number is to assign 0 to one level and 1 to the other level. For example:\nfactor(c(\"rural\", \"rural\", \"metropolitan\", \"rural\")) ## [1] rural rural metropolitan rural ## Levels: metropolitan rural # dummy coded c(0, 0, 1, 0) ## [1] 0 0 1 0 In R, dummy coding is done under the hood for you when using factors, so you don’t have to worry about the conversion.\nWhen the categorical variable has 3 levels instead of 2, we need a work-around in order to code the 3-level factor with only 0s and 1s (we can’t use higher numbers for reasons we will see later).\nWith three levels, we can code the variable using two numeric variables (instead of just one). Going back to the dinosaur’s diet example, we can use:\n One variable that codes whether the dinosaur is a carnivore 0 or a herbivore 1. One variable that codes whether the dinosaur is a carnivore 0 or an omnivore 1.  Let call the first variable dummy_1 and the second variable dummy_2. Then:\n When dummy_1 is 0 and dummy_2 is also 0, the dinosaur is a carnivore. When dummy_1 is 1 and dummy_2 is 0, the dinosaur is a herbivore. When dummy_1 is 0 and dummy_2 is 1, the dinosaur is an omnivore.  So the following factor (repeated from above):\nfactor(c(\"carnivore\", \"carnivore\", \"herbivore\", \"omnivore\", \"herbivore\")) ## [1] carnivore carnivore herbivore omnivore herbivore ## Levels: carnivore herbivore omnivore can be coded as:\ndummy_1  ## # A tibble: 5 x 2 ## dummy_1 dummy_2 ##   ## 1 0 0 ## 2 0 0 ## 3 1 0 ## 4 0 1 ## 5 1 0 If this doesn’t make much sense, try and figure it out by checking the value of the two columns for each row with the following code:\n# case_when() is a very helpful function from dplyr! case_when( dummy_1 == 0 \u0026 dummy_2 == 0 ~ \"carnivore\", dummy_1 == 1 \u0026 dummy_2 == 0 ~ \"herbivore\", dummy_1 == 0 \u0026 dummy_2 == 1 ~ \"omnivore\", ) What if the factor has 4 levels? Then you can code it with 3 dummy variables. And what about 5 levels? Use 4 dummy variables. The number of dummy variables needed is equal to the number of levels minus 1 (\\(n_{dummy} = n_{levels} - 1\\)).\nSumming up To sum up:\n Factors are vectors that code categorical variables. The values in a factor are called levels. Regression models cannot work directly with factors, so these are dummy coded. Dummy coding means converting a factor into one or more numeric variables of 0s and 1s.    Dummy coding and contrasts Now. We’ve seen that dummy coding is simply using dummy numeric variables with 0s and 1s.\nIn fact, this is one way of doing dummy coding. Different ways of doing dummy coding in R are called contrasts. The type of contrasts we have seen so far are called treatment contrasts.\nTreatment contrasts The term treatment contrasts comes from the clinical sciences where you test, for example, the efficacy of a medical intervention (a drug, surgery, etc…) by comparing a control group (which has not received the “treatment”) with a group that has received the medical intervention (the treatment group).\nThe control group can be used as the reference group to see if the treatment group has benefited from the medical treatment (i.e. if the treatment group’s health has improved after the intervention relative to the control group, then one can infer that the treatment was effective).\nLet’s look at treatment contrasts in R.\nIn the previous section, we’ve been illustrating dummy coding by assigning 0s and 1s using one or more dummy variables. In practice, you do not need to do that to run real analyses, because R does that under the hood for you.\nFactors in R are coded with treatment contrasts by default. Also by default, the first level is set as the reference level (the order is alphabetical by default). The reference level is the level that gets coded only with 0s, as we have seen above for the dinosaur’s diet factor (carnivorous had dummy_1 = 0 and dummy_2 = 0).\nLet’s see an example using a data table with measurements of vowel duration.\nload(\"./static/data/vowels.rda\") glimpse(vowels) ## Rows: 886 ## Columns: 9 ## $ item  20, 2, 11, 1, 15, 10, 13, 3, 14, 19, 4, 6, 16, 17, 5, 23… ## $ speaker  \"it01\", \"it01\", \"it01\", \"it01\", \"it01\", \"it01\", \"it01\", … ## $ word  \"pugu\", \"pada\", \"poco\", \"pata\", \"boco\", \"podo\", \"boto\", … ## $ v1_duration  95.23720, 138.96844, 126.93226, 127.49888, 132.33310, 12… ## $ c2_voicing  \"voiced\", \"voiced\", \"voiceless\", \"voiceless\", \"voiceless… ## $ vowel  \"u\", \"a\", \"o\", \"a\", \"o\", \"o\", \"o\", \"a\", \"o\", \"u\", \"a\", \"… ## $ c2_place  \"velar\", \"coronal\", \"velar\", \"coronal\", \"velar\", \"corona… ## $ speech_rate  4.893206, 5.015636, 4.819541, 5.031662, 5.063435, 5.0632… ## $ speech_rate_c  -0.55937531, -0.43694485, -0.63303978, -0.42091937, -0.3… For example, let’s take the vowel column. This column indicates which vowel the measurement was taken from, and that can be /a/, /o/, or /u/.\nIf we convert the vowel column into a factor, the levels will be a, o and u, and a will be the reference level.\nvowels % mutate(vowel = as.factor(vowel)) levels(vowels$vowel) ## [1] \"a\" \"o\" \"u\" To get a sense of how a factor would be coded with treatment contrasts, we can print a dummy coding table with the contr.treatment() function.\ncontr.treatment(levels(vowels$vowel)) ## o u ## a 0 0 ## o 1 0 ## u 0 1 Now, let’s run a regression model with v1_duration as the outcome variable and vowel as the predictor.\nvow_lm  ## ## Call: ## lm(formula = v1_duration ~ vowel, data = vowels) ## ## Residuals: ## Min 1Q Median 3Q Max ## -66.874 -22.567 -2.293 17.025 106.755 ## ## Coefficients: ## Estimate Std. Error t value Pr(|t|) ## (Intercept) 128.616 1.806 71.227  The summary returns three coefficients:\n Intercept. vowelo. vowelu.  Since a is the reference level of vowel, the Intercept corresponds to the mean duration of the vowel a, i.e. 128 ms.\nThe coefficient of o is the difference between the mean duration of o and the mean duration of the reference level a (i.e. the Intercept). So o is 5.6 ms shorter than a on average (shorter because the coefficient is negative).\nFinally, the coefficient of u is the difference between the mean duration of u and the mean duration of the reference level a So u is 29.7 ms shorter than a.\nThis is how treatment contrasts work.\n Sum contrasts Another type of contrast are the so-called sum contrasts.\nWhen using sum contrasts, the levels in a factor are coded using 1s, -1s and 0s. If you sum the values of each dummy variable you always get 0 (hence the name “sum” contrast).\nLet’s see what happens to the factor vowel when using sum contrasts (remember that factors use treatment contrasts by default).\nThis is how sum coding would look like for this factor:\ncontr.sum(levels(vowels$vowel)) ## [,1] [,2] ## a 1 0 ## o 0 1 ## u -1 -1 Since there are 3 levels, we need two dummy variables. So a is coded as 1, 0, o is coded as 0, 1, and u as -1, -1.\nTo set the contrasts of a factor to sum coding, we can run the following:\ncontrasts(vowels$vowel)  With sum contrasts the reference level is in fact the grand mean.\nIn our model of vowel duration this means that the Intercept coefficient will be the grand mean of vowel duration.\nLet’s rerun the model and look at the output.\nvow_lm  ## ## Call: ## lm(formula = v1_duration ~ vowel, data = vowels) ## ## Residuals: ## Min 1Q Median 3Q Max ## -66.874 -22.567 -2.293 17.025 106.755 ## ## Coefficients: ## Estimate Std. Error t value Pr(|t|) ## (Intercept) 116.815 1.055 110.728  The Intercept now is 116 ms, which mean that the mean of vowel duration across the three vowels is 116 ms.\nWe can check this by taking the mean:\nmean(vowels$v1_duration) ## [1] 117.2747 Yup, pretty close (small differences are fine).\nSo what are now the coefficients called vowel1 and vowel2?\nThese are, respectively, the difference between the mean duration of a and the grand mean, and the difference between the mean duration of o and the grand mean.\nSo a is 11.8 ms longer than the grand mean, and o is 6.1 ms longer than the grand mean.\nWhat about u then?\nEasy. You just subtract the coefficients of both a and o from the grand mean: \\(116.8 - 11.8 - 6.1 = 98.9\\).\nIf you want to check that this is correct, the mean duration of u according to the model above where we used treatment contrasts was \\(128.616 - 29.763 = 98.853\\).\n Sum contrasts and interactions Sum contrasts can be very handy when the model contains interactions between factors.\nLet’s say we want to include in our model of vowel duration a predictor that specifies the voicing of the stop following the vowel. We also add an interaction between vowel and voicing, so that we can model differences in the effect of voicing across vowels.\nvow_lm_2  ## ## Call: ## lm(formula = v1_duration ~ c2_voicing + vowel + c2_voicing:vowel, ## data = vowels) ## ## Residuals: ## Min 1Q Median 3Q Max ## -64.905 -23.262 -2.033 18.134 115.813 ## ## Coefficients: ## Estimate Std. Error t value Pr(|t|) ## (Intercept) 123.469 1.449 85.232  Now the Intercept is the mean vowel duration when the following stop is voiced (the reference level of c2_voicing). This means that the average vowel followed by a voiced stop is 123 ms long in our data.\nThe coefficient of c2_voicingvoiceless tells us the mean effect of c2_voicing on vowel duration, averaged across all vowels. So, on average, a vowel is about 13 ms shorter when followed by a voiceless stop.\nThe coefficients of vowel1 and vowel2 indicate the difference between the average vowel duration before a voiced stop (the Intercept) and a and o respectively. As before, to get the difference between the average vowel duration of u before a voiceless stop and the mean vowel duration, you just need to subtract the coefficients of vowel1 and vowel2 from the Intercept: \\(123.5 - 14.6 - 8.5 = 100.4\\).\nThe last two coefficients, c2_voicingvoiceless:vowel1 and c2_voicingvoiceless:vowel2 correspond to the difference in the effect of voicing between the average effect of voicing (c2_voicingvoiceless, i.e. -13 ms) and the effect of voicing in a and o respectively. That is, the decrease of vowel duration for a is 5.6 ms greater than the average effect, while the decrease of vowel duration for o is 4.8 ms greater than the average effect.\nFollowing the usual formula, the effect of voicing for u is \\(-13.309 - (-5.6) - (-4.8) = -2.9\\).\n   A previous version of this post is also featured as a vignette in the learnB4SS package, https://learnb4ss.github.io/learnB4SS/articles/contrasts.html↩︎\n   ",
  "wordCount" : "2352",
  "inLanguage": "en",
  "datePublished": "2021-07-20T00:00:00Z",
  "dateModified": "2021-07-20T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Stefano Coretta"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://stefanocoretta.github.io/post/contrasts/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Stefano Coretta",
    "logo": {
      "@type": "ImageObject",
      "url": "https://stefanocoretta.github.io/favicon.ico"
    }
  }
}
</script>





</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }
    </style>

</noscript>
<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://stefanocoretta.github.io" accesskey="h" title="Stefano Coretta (Alt + H)">Stefano Coretta</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                
                
            </span>
        </div>
        <ul id="menu" onscroll="menu_on_scroll()">
            <li>
                <a href="https://stefanocoretta.github.io" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://stefanocoretta.github.io/research/" title="Research">
                    <span>Research</span>
                </a>
            </li>
            <li>
                <a href="https://stefanocoretta.github.io/meta/" title="Meta">
                    <span>Meta</span>
                </a>
            </li>
            <li>
                <a href="https://stefanocoretta.github.io/output/" title="Output">
                    <span>Output</span>
                </a>
            </li>
            <li>
                <a href="https://stefanocoretta.github.io/archives/" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
            <li>
                <a href="https://stefanocoretta.github.io/docs/CorettaCV.pdf" title="CV">
                    <span>CV</span>
                </a>
            </li></ul>
    </nav>
</header>

    <main class="main">

<article class="post-single">
  <header class="post-header">

    <h1 class="post-title">
      Factors, dummy coding and contrasts
    </h1>
    <div class="post-meta">

July 20, 2021&nbsp;·&nbsp;12 min&nbsp;·&nbsp;Stefano Coretta


</div>
  </header> 

  <div class="post-content">

<script src="https://stefanocoretta.github.io/post/contrasts/index_files/header-attrs/header-attrs.js"></script>


<p>This post is an overview of how factors (i.e. categorical variables) are coded under the hood using dummy coding and which types of dummy coding can be set in R.<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a></p>
<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>There’s seems to be a bit of terminological mix-up in the wild, so we first present a terminological set that will be used throughout the vignette.</p>
<p>Categorical variables in R are generally stored using factors.
A <strong>factor</strong> is a vector of values from a categorical variable.
The possible values in a factor are called <strong>levels</strong> in R.</p>
<p>For each observation in the factor, the vector specifies the level of that observation.</p>
<p>For example, let’s assume we have a data set with information on dinosaurs and one column specifies the dinosaur’s diet: <code>carnivore</code>, <code>herbivore</code>, <code>omnivore</code>.</p>
<p>In R, this column can be coded as a factor:</p>
<pre class="r"><code>factor(c(&quot;carnivore&quot;, &quot;carnivore&quot;, &quot;herbivore&quot;, &quot;omnivore&quot;, &quot;herbivore&quot;))</code></pre>
<pre><code>## [1] carnivore carnivore herbivore omnivore  herbivore
## Levels: carnivore herbivore omnivore</code></pre>
<p>We are so accustomed to using factors in regression models that sometimes we forget that regressions only work with numbers and cannot work with categorical variables.</p>
<p>To fit a regression model with categorical variables, these are first converted to numbers.
The process of conversion is called <strong>dummy variable coding</strong> or simply <strong>dummy coding</strong>.
This consists of assigning <code>0</code>s or <code>1</code>s to the levels in the variable.</p>
<p>Let’s go through a simple example of dummy coding of a categorical variable with only 2 levels: <code>metropolitan</code> and <code>rural</code>.</p>
<p>The most simple way of coding this categorical variable as a number is to assign <code>0</code> to one level and <code>1</code> to the other level. For example:</p>
<pre class="r"><code>factor(c(&quot;rural&quot;, &quot;rural&quot;, &quot;metropolitan&quot;, &quot;rural&quot;))</code></pre>
<pre><code>## [1] rural        rural        metropolitan rural       
## Levels: metropolitan rural</code></pre>
<pre class="r"><code># dummy coded
c(0, 0, 1, 0)</code></pre>
<pre><code>## [1] 0 0 1 0</code></pre>
<p>In R, dummy coding is done under the hood for you when using factors, so you don’t have to worry about the conversion.</p>
<p>When the categorical variable has 3 levels instead of 2, we need a work-around in order to code the 3-level factor with only <code>0</code>s and <code>1</code>s (we can’t use higher numbers for reasons we will see later).</p>
<p>With three levels, we can code the variable using two numeric variables (instead of just one).
Going back to the dinosaur’s diet example, we can use:</p>
<ul>
<li>One variable that codes whether the dinosaur is a carnivore <code>0</code> or a herbivore <code>1</code>.</li>
<li>One variable that codes whether the dinosaur is a carnivore <code>0</code> or an omnivore <code>1</code>.</li>
</ul>
<p>Let call the first variable <code>dummy_1</code> and the second variable <code>dummy_2</code>. Then:</p>
<ul>
<li>When <code>dummy_1</code> is <code>0</code> and <code>dummy_2</code> is also <code>0</code>, the dinosaur is a carnivore.</li>
<li>When <code>dummy_1</code> is <code>1</code> and <code>dummy_2</code> is <code>0</code>, the dinosaur is a herbivore.</li>
<li>When <code>dummy_1</code> is <code>0</code> and <code>dummy_2</code> is <code>1</code>, the dinosaur is an omnivore.</li>
</ul>
<p>So the following factor (repeated from above):</p>
<pre class="r"><code>factor(c(&quot;carnivore&quot;, &quot;carnivore&quot;, &quot;herbivore&quot;, &quot;omnivore&quot;, &quot;herbivore&quot;))</code></pre>
<pre><code>## [1] carnivore carnivore herbivore omnivore  herbivore
## Levels: carnivore herbivore omnivore</code></pre>
<p>can be coded as:</p>
<pre class="r"><code>dummy_1 &lt;- c(0, 0, 1, 0, 1)     # carnivore (0) or herbivore (1)?
dummy_2 &lt;- c(0, 0, 0, 1, 0)     # carnivore (0) or omnivore (1)?

library(tidyverse)

tibble(
  dummy_1, dummy_2
)</code></pre>
<pre><code>## # A tibble: 5 x 2
##   dummy_1 dummy_2
##     &lt;dbl&gt;   &lt;dbl&gt;
## 1       0       0
## 2       0       0
## 3       1       0
## 4       0       1
## 5       1       0</code></pre>
<p>If this doesn’t make much sense, try and figure it out by checking the value of the two columns for each row with the following code:</p>
<pre class="r"><code># case_when() is a very helpful function from dplyr!

case_when(
  dummy_1 == 0 &amp; dummy_2 == 0 ~ &quot;carnivore&quot;,
  dummy_1 == 1 &amp; dummy_2 == 0 ~ &quot;herbivore&quot;,
  dummy_1 == 0 &amp; dummy_2 == 1 ~ &quot;omnivore&quot;,
)</code></pre>
<p>What if the factor has 4 levels? Then you can code it with 3 dummy variables. And what about 5 levels? Use 4 dummy variables. The number of dummy variables needed is equal to the number of levels minus 1 (<span class="math inline">\(n_{dummy} = n_{levels} - 1\)</span>).</p>
<div id="summing-up" class="section level2">
<h2>Summing up</h2>
<p>To sum up:</p>
<ul>
<li><strong>Factors</strong> are vectors that code categorical variables.</li>
<li>The values in a factor are called <strong>levels</strong>.</li>
<li>Regression models cannot work directly with factors, so these are dummy coded.</li>
<li><strong>Dummy coding</strong> means converting a factor into one or more numeric variables of <code>0</code>s and <code>1</code>s.</li>
</ul>
</div>
</div>
<div id="dummy-coding-and-contrasts" class="section level1">
<h1>Dummy coding and contrasts</h1>
<p>Now. We’ve seen that dummy coding is simply using dummy numeric variables with <code>0</code>s and <code>1</code>s.</p>
<p>In fact, this is <strong>one way</strong> of doing dummy coding.
Different ways of doing dummy coding in R are called <strong>contrasts</strong>.
The type of contrasts we have seen so far are called <strong>treatment contrasts</strong>.</p>
<div id="treatment-contrasts" class="section level2">
<h2>Treatment contrasts</h2>
<p>The term <strong>treatment contrasts</strong> comes from the clinical sciences where you test, for example, the efficacy of a medical intervention (a drug, surgery, etc…) by comparing a <strong>control group</strong> (which has not received the “treatment”) with a group that has received the medical intervention (the <strong>treatment group</strong>).</p>
<p>The control group can be used as the reference group to see if the treatment group has benefited from the medical treatment (i.e. if the treatment group’s health has improved after the intervention relative to the control group, then one can infer that the treatment was effective).</p>
<p>Let’s look at treatment contrasts in R.</p>
<p>In the previous section, we’ve been illustrating dummy coding by assigning <code>0</code>s and <code>1</code>s using one or more dummy variables.
In practice, you do not need to do that to run real analyses, because R does that under the hood for you.</p>
<p>Factors in R are coded with treatment contrasts by default.
Also by default, the first level is set as the reference level (the order is alphabetical by default).
The reference level is the level that gets coded only with <code>0</code>s, as we have seen above for the dinosaur’s diet factor (<code>carnivorous</code> had <code>dummy_1 = 0</code> and <code>dummy_2 = 0</code>).</p>
<p>Let’s see an example using a data table with measurements of vowel duration.</p>
<pre class="r"><code>load(&quot;./static/data/vowels.rda&quot;)
glimpse(vowels)</code></pre>
<pre><code>## Rows: 886
## Columns: 9
## $ item          &lt;dbl&gt; 20, 2, 11, 1, 15, 10, 13, 3, 14, 19, 4, 6, 16, 17, 5, 23…
## $ speaker       &lt;chr&gt; &quot;it01&quot;, &quot;it01&quot;, &quot;it01&quot;, &quot;it01&quot;, &quot;it01&quot;, &quot;it01&quot;, &quot;it01&quot;, …
## $ word          &lt;chr&gt; &quot;pugu&quot;, &quot;pada&quot;, &quot;poco&quot;, &quot;pata&quot;, &quot;boco&quot;, &quot;podo&quot;, &quot;boto&quot;, …
## $ v1_duration   &lt;dbl&gt; 95.23720, 138.96844, 126.93226, 127.49888, 132.33310, 12…
## $ c2_voicing    &lt;chr&gt; &quot;voiced&quot;, &quot;voiced&quot;, &quot;voiceless&quot;, &quot;voiceless&quot;, &quot;voiceless…
## $ vowel         &lt;chr&gt; &quot;u&quot;, &quot;a&quot;, &quot;o&quot;, &quot;a&quot;, &quot;o&quot;, &quot;o&quot;, &quot;o&quot;, &quot;a&quot;, &quot;o&quot;, &quot;u&quot;, &quot;a&quot;, &quot;…
## $ c2_place      &lt;chr&gt; &quot;velar&quot;, &quot;coronal&quot;, &quot;velar&quot;, &quot;coronal&quot;, &quot;velar&quot;, &quot;corona…
## $ speech_rate   &lt;dbl&gt; 4.893206, 5.015636, 4.819541, 5.031662, 5.063435, 5.0632…
## $ speech_rate_c &lt;dbl&gt; -0.55937531, -0.43694485, -0.63303978, -0.42091937, -0.3…</code></pre>
<p>For example, let’s take the <code>vowel</code> column.
This column indicates which vowel the measurement was taken from, and that can be /a/, /o/, or /u/.</p>
<p>If we convert the <code>vowel</code> column into a factor, the levels will be <code>a</code>, <code>o</code> and <code>u</code>, and <code>a</code> will be the reference level.</p>
<pre class="r"><code>vowels &lt;- vowels %&gt;%
  mutate(vowel = as.factor(vowel))

levels(vowels$vowel)</code></pre>
<pre><code>## [1] &quot;a&quot; &quot;o&quot; &quot;u&quot;</code></pre>
<p>To get a sense of how a factor would be coded with treatment contrasts, we can print a dummy coding table with the <code>contr.treatment()</code> function.</p>
<pre class="r"><code>contr.treatment(levels(vowels$vowel))</code></pre>
<pre><code>##   o u
## a 0 0
## o 1 0
## u 0 1</code></pre>
<p>Now, let’s run a regression model with <code>v1_duration</code> as the outcome variable and <code>vowel</code> as the predictor.</p>
<pre class="r"><code>vow_lm &lt;- lm(v1_duration ~ vowel, data = vowels)

summary(vow_lm)</code></pre>
<pre><code>## 
## Call:
## lm(formula = v1_duration ~ vowel, data = vowels)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -66.874 -22.567  -2.293  17.025 106.755 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept)  128.616      1.806  71.227   &lt;2e-16 ***
## vowelo        -5.641      2.549  -2.213   0.0272 *  
## vowelu       -29.763      2.603 -11.432   &lt;2e-16 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 31.38 on 883 degrees of freedom
## Multiple R-squared:  0.1419, Adjusted R-squared:  0.1399 
## F-statistic: 72.99 on 2 and 883 DF,  p-value: &lt; 2.2e-16</code></pre>
<p>The summary returns three coefficients:</p>
<ul>
<li><code>Intercept</code>.</li>
<li><code>vowelo</code>.</li>
<li><code>vowelu</code>.</li>
</ul>
<p>Since <code>a</code> is the reference level of <code>vowel</code>, the <code>Intercept</code> corresponds to the mean duration of the vowel <code>a</code>, i.e. 128 ms.</p>
<p>The coefficient of <code>o</code> is the <strong>difference between the mean duration of <code>o</code> and the mean duration of the reference level <code>a</code></strong> (i.e. the <code>Intercept</code>).
So <code>o</code> is 5.6 ms shorter than <code>a</code> on average (shorter because the coefficient is negative).</p>
<p>Finally, the coefficient of <code>u</code> is the <strong>difference between the mean duration of <code>u</code> and the mean duration of the reference level <code>a</code></strong>
So <code>u</code> is 29.7 ms shorter than <code>a</code>.</p>
<p>This is how treatment contrasts work.</p>
</div>
<div id="sum-contrasts" class="section level2">
<h2>Sum contrasts</h2>
<p>Another type of contrast are the so-called <strong>sum contrasts</strong>.</p>
<p>When using sum contrasts, the levels in a factor are coded using <code>1</code>s, <code>-1</code>s and <code>0</code>s.
If you sum the values of each dummy variable you always get <code>0</code> (hence the name “sum” contrast).</p>
<p>Let’s see what happens to the factor <code>vowel</code> when using sum contrasts (remember that factors use treatment contrasts by default).</p>
<p>This is how sum coding would look like for this factor:</p>
<pre class="r"><code>contr.sum(levels(vowels$vowel))</code></pre>
<pre><code>##   [,1] [,2]
## a    1    0
## o    0    1
## u   -1   -1</code></pre>
<p>Since there are 3 levels, we need two dummy variables.
So <code>a</code> is coded as <code>1, 0</code>, <code>o</code> is coded as <code>0, 1</code>, and <code>u</code> as <code>-1, -1</code>.</p>
<p>To set the contrasts of a factor to sum coding, we can run the following:</p>
<pre class="r"><code>contrasts(vowels$vowel) &lt;- &quot;contr.sum&quot;
# If you want to change it back to treatment contrasts you can run
# contrasts(vowels$vowel) &lt;- &quot;contr.treatment&quot;</code></pre>
<p>With sum contrasts the reference level is in fact the grand mean.</p>
<p>In our model of vowel duration this means that the <code>Intercept</code> coefficient will be the grand mean of vowel duration.</p>
<p>Let’s rerun the model and look at the output.</p>
<pre class="r"><code>vow_lm &lt;- lm(v1_duration ~ vowel, data = vowels)

summary(vow_lm)</code></pre>
<pre><code>## 
## Call:
## lm(formula = v1_duration ~ vowel, data = vowels)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -66.874 -22.567  -2.293  17.025 106.755 
## 
## Coefficients:
##             Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept)  116.815      1.055 110.728  &lt; 2e-16 ***
## vowel1        11.801      1.483   7.957 5.40e-15 ***
## vowel2         6.160      1.481   4.160 3.49e-05 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 31.38 on 883 degrees of freedom
## Multiple R-squared:  0.1419, Adjusted R-squared:  0.1399 
## F-statistic: 72.99 on 2 and 883 DF,  p-value: &lt; 2.2e-16</code></pre>
<p>The <code>Intercept</code> now is 116 ms, which mean that the mean of vowel duration across the three vowels is 116 ms.</p>
<p>We can check this by taking the mean:</p>
<pre class="r"><code>mean(vowels$v1_duration)</code></pre>
<pre><code>## [1] 117.2747</code></pre>
<p>Yup, pretty close (small differences are fine).</p>
<p>So what are now the coefficients called <code>vowel1</code> and <code>vowel2</code>?</p>
<p>These are, respectively, the difference between the mean duration of <code>a</code> and the grand mean, and the difference between the mean duration of <code>o</code> and the grand mean.</p>
<p>So <code>a</code> is 11.8 ms longer than the grand mean, and <code>o</code> is 6.1 ms longer than the grand mean.</p>
<p>What about <code>u</code> then?</p>
<p>Easy.
You just subtract the coefficients of both <code>a</code> and <code>o</code> from the grand mean: <span class="math inline">\(116.8 - 11.8 - 6.1 = 98.9\)</span>.</p>
<p>If you want to check that this is correct, the mean duration of <code>u</code> according to the model above where we used treatment contrasts was <span class="math inline">\(128.616 - 29.763 = 98.853\)</span>.</p>
</div>
<div id="sum-contrasts-and-interactions" class="section level2">
<h2>Sum contrasts and interactions</h2>
<p>Sum contrasts can be very handy when the model contains interactions between factors.</p>
<p>Let’s say we want to include in our model of vowel duration a predictor that specifies the voicing of the stop following the vowel.
We also add an interaction between vowel and voicing, so that we can model differences in the effect of voicing across vowels.</p>
<pre class="r"><code>vow_lm_2 &lt;- lm(v1_duration ~ c2_voicing + vowel + c2_voicing:vowel, data = vowels)

summary(vow_lm_2)</code></pre>
<pre><code>## 
## Call:
## lm(formula = v1_duration ~ c2_voicing + vowel + c2_voicing:vowel, 
##     data = vowels)
## 
## Residuals:
##     Min      1Q  Median      3Q     Max 
## -64.905 -23.262  -2.033  18.134 115.813 
## 
## Coefficients:
##                            Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept)                 123.469      1.449  85.232  &lt; 2e-16 ***
## c2_voicingvoiceless         -13.309      2.049  -6.496 1.37e-10 ***
## vowel1                       14.606      2.037   7.171 1.57e-12 ***
## vowel2                        8.564      2.033   4.212 2.79e-05 ***
## c2_voicingvoiceless:vowel1   -5.609      2.880  -1.947   0.0518 .  
## c2_voicingvoiceless:vowel2   -4.808      2.876  -1.672   0.0949 .  
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## Residual standard error: 30.47 on 880 degrees of freedom
## Multiple R-squared:  0.1937, Adjusted R-squared:  0.1891 
## F-statistic: 42.29 on 5 and 880 DF,  p-value: &lt; 2.2e-16</code></pre>
<p>Now the <code>Intercept</code> is the mean vowel duration when the following stop is voiced (the reference level of <code>c2_voicing</code>).
This means that the average vowel followed by a voiced stop is 123 ms long in our data.</p>
<p>The coefficient of <code>c2_voicingvoiceless</code> tells us the mean effect of <code>c2_voicing</code> on vowel duration, averaged across all vowels.
So, on average, a vowel is about 13 ms shorter when followed by a voiceless stop.</p>
<p>The coefficients of <code>vowel1</code> and <code>vowel2</code> indicate the difference between the average vowel duration before a voiced stop (the <code>Intercept</code>) and <code>a</code> and <code>o</code> respectively.
As before, to get the difference between the average vowel duration of <code>u</code> before a voiceless stop and the mean vowel duration, you just need to subtract the coefficients of <code>vowel1</code> and <code>vowel2</code> from the <code>Intercept</code>: <span class="math inline">\(123.5 - 14.6 - 8.5 = 100.4\)</span>.</p>
<p>The last two coefficients, <code>c2_voicingvoiceless:vowel1</code> and <code>c2_voicingvoiceless:vowel2</code> correspond to the difference in the effect of voicing between the average effect of voicing (<code>c2_voicingvoiceless</code>, i.e. -13 ms) and the effect of voicing in <code>a</code> and <code>o</code> respectively.
That is, the decrease of vowel duration for <code>a</code> is 5.6 ms greater than the average effect, while the decrease of vowel duration for <code>o</code> is 4.8 ms greater than the average effect.</p>
<p>Following the usual formula, the effect of voicing for <code>u</code> is <span class="math inline">\(-13.309 - (-5.6) - (-4.8) = -2.9\)</span>.</p>
</div>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>A previous version of this post is also featured as a vignette in the learnB4SS package, <a href="https://learnb4ss.github.io/learnB4SS/articles/contrasts.html" class="uri">https://learnb4ss.github.io/learnB4SS/articles/contrasts.html</a><a href="#fnref1" class="footnote-back">↩︎</a></p></li>
</ol>
</div>

</div>
  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://stefanocoretta.github.io/tags/statistics/">statistics</a></li>
      <li><a href="https://stefanocoretta.github.io/tags/rstats/">rstats</a></li>
    </ul>
  </footer>
</article>
    </main><footer class="footer">
    <span>&copy; 2021 <a href="https://stefanocoretta.github.io">Stefano Coretta</a></span>
    <span>&middot;</span>
    <span>Powered by <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a></span>
    <span>&middot;</span>
    <span>Theme <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>



<script defer src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<script>
    window.onload = function () {
        if (localStorage.getItem("menu-scroll-position")) {
            document.getElementById('menu').scrollLeft = localStorage.getItem("menu-scroll-position");
        }
    }

    function menu_on_scroll() {
        localStorage.setItem("menu-scroll-position", document.getElementById('menu').scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>

</body>

</html>
