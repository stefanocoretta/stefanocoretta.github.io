<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.56">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Stefano Coretta">
<meta name="dcterms.date" content="2021-04-24">

<title>On phonologisation – Stefano Coretta</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../img/favicon.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Stefano Coretta</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../research.html"> 
<span class="menu-text">Research</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../teaching.html"> 
<span class="menu-text">Teaching</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../meta.html"> 
<span class="menu-text">Meta</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../output/index.html"> 
<span class="menu-text">Output</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../files/CorettaCV.pdf"> 
<span class="menu-text">CV</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#five-definitions-of-phonologisation" id="toc-five-definitions-of-phonologisation" class="nav-link active" data-scroll-target="#five-definitions-of-phonologisation"><span class="header-section-number">1</span> Five definitions of phonologisation</a></li>
  <li><a href="#structuralism" id="toc-structuralism" class="nav-link" data-scroll-target="#structuralism"><span class="header-section-number">2</span> Structuralism</a></li>
  <li><a href="#lexical-phonology" id="toc-lexical-phonology" class="nav-link" data-scroll-target="#lexical-phonology"><span class="header-section-number">3</span> Lexical Phonology</a></li>
  <li><a href="#stratal-optimality-theory" id="toc-stratal-optimality-theory" class="nav-link" data-scroll-target="#stratal-optimality-theory"><span class="header-section-number">4</span> Stratal Optimality Theory</a></li>
  <li><a href="#life-cycle-of-phonological-processes" id="toc-life-cycle-of-phonological-processes" class="nav-link" data-scroll-target="#life-cycle-of-phonological-processes"><span class="header-section-number">5</span> Life-Cycle of Phonological Processes</a></li>
  <li><a href="#exemplar-theory" id="toc-exemplar-theory" class="nav-link" data-scroll-target="#exemplar-theory"><span class="header-section-number">6</span> Exemplar Theory</a>
  <ul class="collapse">
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references"><span class="header-section-number">6.1</span> References</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">On phonologisation</h1>
  <div class="quarto-categories">
    <div class="quarto-category">Linguistics</div>
  </div>
  </div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Stefano Coretta </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">April 24, 2021</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<!-- NOTE: Add that it is a diachronic process -->
<p>After the <a href="../2021-03-15-on-random-effects/">post</a> on the definition of random effects, I thought about writing another one on the definition of <span class="smallcaps">phonologisation</span>.</p>
<p>As part of my <a href="https://stefanocoretta.github.io/phd-dissertation/s-ve.html#s:ve-phonologise">PhD thesis</a> on the effect of consonant voicing on vowel duration, I briefly reviewed the five definitions of phonologisation I could find in the literature. This post includes text from my thesis and expands on a few points.</p>
<p>The main take-away of the sections to follow is that what one means with phonologisation is (unsurprisingly) dependent on the set of assumptions that are part of the framework within which the term is used. Secondly, these definitions are mutually exclusive, to an extent such that one’s argument based on one definition might be inappropriate under another definition. It is thus important to always contextualise the use of the term when employed, even when the meaning might be self-evident from the context.</p>
<section id="five-definitions-of-phonologisation" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Five definitions of phonologisation</h1>
<p>I could identify at least five different definitions of phonologisation (but there are surely more). These differ substantially, as mentioned above, and are in the most part incompatible with one another. The five definitions are found within the following general phonological frameworks:</p>
<ul>
<li>Structuralism (i.e.&nbsp;classical/traditional phonology).</li>
<li>Lexical Phonology.</li>
<li>Stratal Optimality Theory.</li>
<li>Life-Cycle of Phonological Processes (an extension of Stratal OT).</li>
<li>Exemplar-based models.</li>
</ul>
<p>I will discuss each of these in turn.</p>
</section>
<section id="structuralism" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Structuralism</h1>
<p>The <strong>classical</strong> or <strong>structuralist</strong> definition states that <strong><em>phonologisation</em> occurs when a contextual allophone becomes contrastive</strong>, or in other words it becomes a phoneme <span class="citation" data-cites="kiparsky2015">(<a href="#ref-kiparsky2015" role="doc-biblioref">Kiparsky 2015</a>)</span>, generally after the disappearance or replacement of the conditioning context.</p>
<p>A classical example of phonologisation concerns the development of a contrast between velar and palatal consonants from velar consonants in Sanskrit <span class="citation" data-cites="hock1991">(<a href="#ref-hock1991" role="doc-biblioref">Hock 1991: 149</a>)</span>. At some point in the history of Sanskrit, the velar stops /k/ and /g/ (which derived from PIE velars and labialised velars) where palatalised when followed by /i/ and /e/, creating an allophonic distinction between velars proper and palatal consonants.</p>
<p>The subsequent change of /e/ (and /o/) to /a/ removed the context conditioning palatalisation (the front vowel /e/), thus creating minimal pairs opposing /ka, ga/ and /tʃa, dʒa/. At this stage, the palatal allophones were phonologised.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>sound change</th>
<th>phonemic</th>
<th>phonetic</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td>/ka, ke/</td>
<td>[ka, ke]</td>
</tr>
<tr class="even">
<td>palatalisation</td>
<td>/ka, ke/</td>
<td>[ka, tʃe]</td>
</tr>
<tr class="odd">
<td>/e/ &gt; /a/</td>
<td>/ka, tʃa/</td>
<td>[ka, tʃa]</td>
</tr>
</tbody>
</table>
<p>The IE roots for ‘what’ and ‘and’ illustrate the phonologisation of the palatal consonants.</p>
<ul>
<li>PIE *<em>kʷod</em> &gt; Skt. /kad/ <em>kád</em> ‘what’ (cf.&nbsp;Lat. <em>quod</em>).</li>
<li>PIE *-<em>kʷe</em> &gt; Skt. /ke/ [tʃe] &gt; /tʃa/ -<em>ca</em> ‘and’ (cf.&nbsp;Lat. <em>-que</em>).</li>
</ul>
<p>This conceptualisation of phonologisation amounts to saying that phonetic features that were previously computed procedurally (during phonological/phonetic derivation) from an underlying lexical representation are now instead already part of the lexical representation (which is, in structural terms, a string of phonemes/features/elements).</p>
</section>
<section id="lexical-phonology" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Lexical Phonology</h1>
<p>Phonologisation assumes a different meaning within the framework of <strong>Lexical Phonology</strong> <span class="citation" data-cites="kiparsky1988">(<a href="#ref-kiparsky1988" role="doc-biblioref">Kiparsky 1988</a>)</span>. Lexical Phonology argues that there exist two types of phonological processes: processes that apply at the lexical level (stem and prosodic word), and processes that are post-lexical and apply across the board.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> According to the view of Lexical Phonology, <strong>a process is <em>phonologised</em> when it goes from being post-lexical to being lexical</strong>.</p>
<p>To carry on with the Sanskrit example, palatalisation was initially post-lexical, in other words it was applied across the board during the phonological derivation process after all lexical processes have been applied to the stem and then word. At some point in the history of Sanskrit, the process of velar palatalisation started being applied also at the lexical level (with the original “copy” of the process possibly still being applied post-lexically). Velar palatalisation has been phonologised, creating so called “quasi-phonemes” <span class="citation" data-cites="janda1999">(i.e.&nbsp;categorical, distinctive units, not yet able to create lexical contrast, <a href="#ref-janda1999" role="doc-biblioref">Janda 1999</a>)</span>.</p>
</section>
<section id="stratal-optimality-theory" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Stratal Optimality Theory</h1>
<p><span class="citation" data-cites="kiparsky2000">Kiparsky (<a href="#ref-kiparsky2000" role="doc-biblioref">2000</a>)</span> borrows the definition of phonologisation from Lexical Phonology and applies it to <strong>Stratal Optimality Theory</strong> <span class="citation" data-cites="kiparsky2000 bermudezotero2017">(<a href="#ref-kiparsky2000" role="doc-biblioref">Kiparsky 2000</a>; <a href="#ref-bermudezotero2017" role="doc-biblioref">Bermúdez-Otero 2017</a>)</span>.</p>
<p>Stratal OT assumes that the <span class="smallcaps">phonological module of the grammar</span> is divided into three levels (called strata, or domains) as in Lexical Phonology: the <span class="smallcaps">stem</span>, the <span class="smallcaps">word</span>, and the <span class="smallcaps">phrasal</span> level.</p>
<p>OT constraints, in Stratal OT, are independently ordered in each level, so that within each level different orders allow for different outputs to be selected. Stratal OT also stipulates that phonological constraints apply iteratively (cyclically) from the narrower domain, namely the stem, through the word domain, to the phrasal domain. Under cyclicity, the output of one domain is passed over as input to the next, and so on.</p>
<p>For <span class="citation" data-cites="kiparsky2000">Kiparsky (<a href="#ref-kiparsky2000" role="doc-biblioref">2000</a>)</span>, <strong><em>phonologisation</em> occurs when the constraint ordering of the phrasal domain (the post-lexical level of Lexical Phonology) is copied over to the word and stem domains (the lexical level of Lexical Phonology)</strong>.</p>
</section>
<section id="life-cycle-of-phonological-processes" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Life-Cycle of Phonological Processes</h1>
<p>An extension of Stratal OT, the <strong>Life-Cycle of Phonological Processes</strong> <span class="citation" data-cites="bermudezotero2007 bermudezotero2015">(<a href="#ref-bermudezotero2007" role="doc-biblioref">Bermúdez-Otero 2007</a>; <a href="#ref-bermudezotero2015" role="doc-biblioref">Bermúdez-Otero 2015</a>)</span>, offers yet another definition of phonologisation and a more fine-grained terminological set. <span class="citation" data-cites="bermudezotero2015">Bermúdez-Otero (<a href="#ref-bermudezotero2015" role="doc-biblioref">2015</a>)</span> reserves the term <strong><em>phonologisation</em> for when a physio-physiological (mechanic) phenomenon comes under the control of the speaker/hearer</strong> and becomes part of their grammar (more specifically, part of the phonetic module of the grammar).</p>
<p>The process, once it has entered the grammar, can further ascend through increasingly deeper grammatical modules. A (gradient) phonologised process is said to be <span class="smallcaps">stabilised</span> (and thus categorical) once it is generated by a categorical phonological process, which applies at the phrase level. At this stage, a stabilised process has entered the phonological module of the speaker/hearer.</p>
<p>A stabilised process further undergoes <span class="smallcaps">domain narrowing</span> when it starts being applied at the word level and then at the stem level. In the final step in the ascent of a sound pattern through the grammar, a phonological process comes under morphological and lexical control, until “it may die altogether, leaving behind no more than inert traces in underlying representations” <span class="citation" data-cites="bermudezotero2015">(<a href="#ref-bermudezotero2015" role="doc-biblioref">Bermúdez-Otero 2015: 12</a>)</span>.</p>
</section>
<section id="exemplar-theory" class="level1" data-number="6">
<h1 data-number="6"><span class="header-section-number">6</span> Exemplar Theory</h1>
<p>A further definition of phonologisation comes from <strong>exemplar models of speech perception and production</strong> <span class="citation" data-cites="johnson1997 pierrehumbert2001 soskuthy2018 ambridge2018 todd2019">(<a href="#ref-johnson1997" role="doc-biblioref">Johnson 1997</a>; <a href="#ref-pierrehumbert2001" role="doc-biblioref">Pierrehumbert 2001</a>; <a href="#ref-soskuthy2018" role="doc-biblioref">Sóskuthy et al. 2018</a>; <a href="#ref-ambridge2018" role="doc-biblioref">Ambridge 2018</a>; <a href="#ref-todd2019" role="doc-biblioref">Todd, Pierrehumbert &amp; Hay 2019</a>)</span>.</p>
<p>A core tenet of these models is that speech tokens are stored in memory as so-called <span class="smallcaps">exemplars</span> after having being experienced. Depending on the specifics of the particular model, exemplars are stored at varying degrees of granularity and richness of detail.</p>
<p>Each exemplar consists of a (more or less) faithful representation of the experienced token that generated it, and it thus contains information from multiple levels and factors (phonetic, lexical, syntactic, sociolinguistic, contextual, and so on). Lexical and other linguistic units are represented as sets of exemplars, or <span class="smallcaps">exemplar clouds</span>. The representational space of exemplar clouds is multi-dimensional and can be operationalised as a multivariate distribution (i.e.&nbsp;a joint distribution of multiple variables).</p>
<p>In modular approaches to grammar as briefly expounded above, sound alternations can be encoded (in terms of derivational rules and/or constraints) either at the phonological level or at the phonetic level of representation.</p>
<p>On the other hand, as <span class="citation" data-cites="soskuthy2013">Sóskuthy (<a href="#ref-soskuthy2013" role="doc-biblioref">2013</a>)</span>, pp.&nbsp;183 illustrates, in exemplar-based models all sound alternations are directly encoded by exemplars within the exemplar cloud, at one single level of representation. As soon as an exemplar with new phonetic characteristics is experienced <em>and</em> stored, the representation of that lexical item already contains information about the sound alternation. In this sense, <strong>every type of variation is <em>phonologised</em> (i.e.&nbsp;represented) from the outset as soon as it is experienced by the speaker/hearer and stored in memory</strong>.</p>
<section id="references" class="level2" data-number="6.1">




</section>
</section>


<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">6.1 References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-ambridge2018" class="csl-entry" role="listitem">
Ambridge, Ben. 2018. Against stored abstractions: <span>A</span> radical exemplar model of language acquisition. Pre-print available at PsyArXiv. <a href="https://doi.org/10.2139/ssrn.3219847">https://doi.org/10.2139/ssrn.3219847</a>.
</div>
<div id="ref-bermudezotero2007" class="csl-entry" role="listitem">
Bermúdez-Otero, Ricardo. 2007. Diachronic phonology. In <em>The cambridge handbook of phonology</em>, 517. Cambridge: Cambridge University Press. <a href="https://doi.org/10.1017/CBO9780511486371.022">https://doi.org/10.1017/CBO9780511486371.022</a>.
</div>
<div id="ref-bermudezotero2015" class="csl-entry" role="listitem">
Bermúdez-Otero, Ricardo. 2015. Amphichronic explanation and the life cycle of phonological processes. In <em>The oxford handbook of historical phonology</em>, 374–399. Oxford: Oxford University Press.
</div>
<div id="ref-bermudezotero2017" class="csl-entry" role="listitem">
Bermúdez-Otero, Ricardo. 2017. Stratal phonology. In S. J. Hannahs &amp; Anna R. K. Bosch (eds.), <em>The routledge handbook of phonological theory</em>, 100–134. Routledge. <a href="https://doi.org/10.4324/9781315675428-5">https://doi.org/10.4324/9781315675428-5</a>.
</div>
<div id="ref-hock1991" class="csl-entry" role="listitem">
Hock, Hans Henrich. 1991. <em>Principles of historical linguistics</em>. Berlin: Mouton de Gruyter. <a href="https://doi.org/10.1515/9783110871975">https://doi.org/10.1515/9783110871975</a>.
</div>
<div id="ref-janda1999" class="csl-entry" role="listitem">
Janda, Richard D. 1999. Accounts of phonemic split have been greatly exaggerated—but not enough. In <em>Proceedings of the 14th international congress of phonetic sciences</em>, vol. 14, 329–332.
</div>
<div id="ref-johnson1997" class="csl-entry" role="listitem">
Johnson, Keith. 1997. Speech perception without speaker normalization: An exemplar model. In Keith Johnson &amp; John W. Mullenix (eds.), <em>Talker variability in speech processing</em>, 145–165. San Diego, CA: Academic Press.
</div>
<div id="ref-kiparsky1988" class="csl-entry" role="listitem">
Kiparsky, Paul. 1988. Phonological change. In Frederick J. Newmeyer (ed.), <em>Linguistics: The cambridge survey</em>, vol. 1 Linguistic theory: foundations, 363–415. Cambridge: Cambridge University Press.
</div>
<div id="ref-kiparsky2000" class="csl-entry" role="listitem">
Kiparsky, Paul. 2000. Opacity and cyclicity. <em>The linguistic review</em> 17(2-4). 351–366. <a href="https://doi.org/10.1515/tlir.2000.17.2-4.351">https://doi.org/10.1515/tlir.2000.17.2-4.351</a>.
</div>
<div id="ref-kiparsky2015" class="csl-entry" role="listitem">
Kiparsky, Paul. 2015. Phonologization. In <em>The oxford handbook of historical phonology</em>. 563–579: Oxford: Oxford University Press.
</div>
<div id="ref-pierrehumbert2001" class="csl-entry" role="listitem">
Pierrehumbert, Janet B. 2001. Exemplar dynamics: Word frequency, lenition and contrast. In Joan L. Bybee &amp; Paul J. Hopper (eds.), <em>Frequency and the emergence of linguistic structure</em>, 137–157. Amsterdam Philadelphia: John Benjamins Publishing Company. <a href="https://doi.org/10.1075/tsl.45.08pie">https://doi.org/10.1075/tsl.45.08pie</a>.
</div>
<div id="ref-soskuthy2013" class="csl-entry" role="listitem">
Sóskuthy, Márton. 2013. <em>Phonetic biases and systemic effects in the actuation of sound change</em>. Edinburgh: University of Edinburgh PhD thesis.
</div>
<div id="ref-soskuthy2018" class="csl-entry" role="listitem">
Sóskuthy, Márton, Paul Foulkes, Vincent Hughes &amp; Bill Haddican. 2018. Changing words and sounds: The roles of different cognitive units in sound change. <em>Topics in Cognitive Science</em>. Wiley Online Library 10(4). 1–16. <a href="https://doi.org/10.1111/tops.12346">https://doi.org/10.1111/tops.12346</a>.
</div>
<div id="ref-todd2019" class="csl-entry" role="listitem">
Todd, Simon, Janet B. Pierrehumbert &amp; Jennifer Hay. 2019. Word frequency effects in sound change as a consequence of perceptual asymmetries: An exemplar-based model. <em>Cognition</em> 185. 1–20. <a href="https://doi.org/10.1016/j.cognition.2019.01.004">https://doi.org/10.1016/j.cognition.2019.01.004</a>.
</div>
</div></section><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>Note that in generative phonology, of which Lexical Phonology is a strand, speakers are assumed to store abstract, underlying phonemic forms, or representations, in memory. These underlying forms, to be produced, go through a series of neuro-cognitive processes, or derivation, that generate a surface representation which is then sent to the motor system which executes the motor plan corresponding to that surface representation. The details widely vary depending on the model or framework.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>