<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>data viz | Stefano Coretta</title>
    <link>https://stefanocoretta.github.io/tags/data-viz/</link>
      <atom:link href="https://stefanocoretta.github.io/tags/data-viz/index.xml" rel="self" type="application/rss+xml" />
    <description>data viz</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-uk</language><copyright>© 2017-2020 Stefano Coretta</copyright><lastBuildDate>Mon, 17 Jun 2019 00:00:00 +0000</lastBuildDate>
    <image>
      <url>img/map[gravatar:%!s(bool=false) shape:circle]</url>
      <title>data viz</title>
      <link>https://stefanocoretta.github.io/tags/data-viz/</link>
    </image>
    
    <item>
      <title>Plotting prior distributions with ggplot2</title>
      <link>https://stefanocoretta.github.io/post/plot-prior-distributions-with-ggplot2/</link>
      <pubDate>Mon, 17 Jun 2019 00:00:00 +0000</pubDate>
      <guid>https://stefanocoretta.github.io/post/plot-prior-distributions-with-ggplot2/</guid>
      <description>
&lt;script src=&#34;https://stefanocoretta.github.io/rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;


&lt;p&gt;The choice of priors is a fundamental step of the Bayesian inference process. &lt;span class=&#34;citation&#34;&gt;Vasishth et al. (2018)&lt;/span&gt; recommend plotting the chosen priors to see if they are reasonable.&lt;/p&gt;
&lt;p&gt;In this post I will show how to easily plot prior distributions in &lt;a href=&#34;https://ggplot2.tidyverse.org&#34;&gt;ggplot2&lt;/a&gt; (which is part of the &lt;a href=&#34;https://www.tidyverse.org&#34;&gt;tidyverse&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Let’s load the tidyverse first.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidyverse)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## ── Attaching packages ──────── tidyverse 1.3.0 ──&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## ✓ ggplot2 3.3.0     ✓ purrr   0.3.4
## ✓ tibble  3.0.1     ✓ dplyr   0.8.5
## ✓ tidyr   1.0.2     ✓ stringr 1.4.0
## ✓ readr   1.3.1     ✓ forcats 0.5.0&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## ── Conflicts ─────────── tidyverse_conflicts() ──
## x dplyr::filter() masks stats::filter()
## x dplyr::lag()    masks stats::lag()&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;theme_set(theme_minimal()) # I just like this theme :)&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;plotting-your-priors&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Plotting your priors&lt;/h2&gt;
&lt;p&gt;Let’s start with a simple normal prior with &lt;span class=&#34;math inline&#34;&gt;\(\mu\)&lt;/span&gt; = 0 and &lt;em&gt;sd&lt;/em&gt; = 1.&lt;/p&gt;
&lt;p&gt;The plot is initialised with an empty call to &lt;code&gt;ggplot()&lt;/code&gt;.
As aesthetics, you only need to specify the range of &lt;em&gt;x&lt;/em&gt; values in &lt;code&gt;aes()&lt;/code&gt;.
Here, we use &lt;code&gt;c(-4, 4)&lt;/code&gt;, meaning that the &lt;em&gt;x&lt;/em&gt;-axis of this plot will have these limits.
For a normal distribution, it is useful to set the limits as the mean ± 4 times the standard deviation (this ensures all the distribution is shown).&lt;/p&gt;
&lt;p&gt;The function &lt;code&gt;ggplot2::stat_function()&lt;/code&gt; allows us to specify a distribution family with the &lt;code&gt;fun&lt;/code&gt; argument.
This arguments takes the density function (the R functions of the form &lt;em&gt;dxxx&lt;/em&gt;) of the chosen distribution family, so for the normal (Gaussian) distribution we use &lt;code&gt;dnorm()&lt;/code&gt;.
The argument &lt;code&gt;n&lt;/code&gt; specifies the number of points along which to calculate the distribution (here &lt;code&gt;101&lt;/code&gt;), while &lt;code&gt;args&lt;/code&gt; takes a list with the parameters of the distribution (here the mean &lt;code&gt;0&lt;/code&gt; and standard deviation &lt;code&gt;1&lt;/code&gt;).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot() +
  aes(x = c(-4, 4)) +
  stat_function(fun = dnorm, n = 101, args = list(0, 1)) +
  labs(title = &amp;quot;Normal (Gaussian) distribution&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://stefanocoretta.github.io/post/2019-06-17-plot-prior-distributions-with-ggplot2_files/figure-html/normal-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;If you are using a half-normal prior, you can plot it by setting one of the limits to the mean.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot() +
  # the mean is 0, only positive number are shown
  aes(x = c(0, 4)) +
  stat_function(fun = dnorm, n = 101, args = list(0, 1)) +
  labs(title = &amp;quot;Half-normal distribution&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://stefanocoretta.github.io/post/2019-06-17-plot-prior-distributions-with-ggplot2_files/figure-html/half-normal-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;A beta prior will be bounded between 0 and 1, so we can specify that in &lt;code&gt;aes()&lt;/code&gt;.
The beta distribution has two arguments, &lt;code&gt;shape1&lt;/code&gt; and &lt;code&gt;shape2&lt;/code&gt; (here &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;5&lt;/code&gt;).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot() +
  aes(x = c(0, 1)) +
  stat_function(fun = dbeta, n = 101, args = list(2, 5)) +
  labs(title = &amp;quot;Beta distribution&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://stefanocoretta.github.io/post/2019-06-17-plot-prior-distributions-with-ggplot2_files/figure-html/beta-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Another common distribution is the Cauchy.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot() +
  aes(x = c(-10, 10)) +
  stat_function(fun = dcauchy, n = 201, args = list(-2, 1)) +
  labs(title = &amp;quot;Cauchy distribution&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://stefanocoretta.github.io/post/2019-06-17-plot-prior-distributions-with-ggplot2_files/figure-html/cauchy-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The Poisson distribution can be plotted by changing the type of &lt;code&gt;geom&lt;/code&gt; and using an &lt;code&gt;n&lt;/code&gt; that creates only integers.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# the range 0:20 includes 21 integers, so n = 21
ggplot() +
  aes(x = c(0, 20)) +
  stat_function(fun = dpois, n = 21, args = list(4), geom = &amp;quot;point&amp;quot;) +
  labs(title = &amp;quot;Poisson distribution&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://stefanocoretta.github.io/post/2019-06-17-plot-prior-distributions-with-ggplot2_files/figure-html/poisson-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Of course any family with a corresponding &lt;em&gt;dxxx&lt;/em&gt; function can be plotted (see &lt;code&gt;?Distributions&lt;/code&gt; and package-provided families).&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;references&#34; class=&#34;section level2 unnumbered&#34;&gt;
&lt;h2&gt;References&lt;/h2&gt;
&lt;div id=&#34;refs&#34; class=&#34;references hanging-indent&#34;&gt;
&lt;div id=&#34;ref-vasishth2018&#34;&gt;
&lt;p&gt;Vasishth, Shravan, M. Beckman, B. Nicenboim, Fangfang Li, and Eun Jong Kong. 2018. “Bayesian Data Analysis in the Phonetic Sciences: A Tutorial Introduction.” &lt;em&gt;Journal of Phonetics&lt;/em&gt; 71: 147–61.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Plotting tongue contours with ggplot2</title>
      <link>https://stefanocoretta.github.io/post/plotting-tongue-contours-with-ggplot2/</link>
      <pubDate>Thu, 23 Aug 2018 00:00:00 +0000</pubDate>
      <guid>https://stefanocoretta.github.io/post/plotting-tongue-contours-with-ggplot2/</guid>
      <description>
&lt;script src=&#34;https://stefanocoretta.github.io/rmarkdown-libs/header-attrs/header-attrs.js&#34;&gt;&lt;/script&gt;


&lt;p&gt;When plotting tongue contours data obtained from ultrasound tongue imaging in &lt;code&gt;R&lt;/code&gt; using &lt;code&gt;ggplot2&lt;/code&gt;, a common option to smooth over the individual contours and show the general pattern is to use &lt;code&gt;geom_smooth(methood = &#34;loess&#34;)&lt;/code&gt;. However, as I will show in this post, in certain cases this method leads to very disorted contours. Such distortion is more or less always present, although at a lower degree in less extreme cases.&lt;/p&gt;
&lt;p&gt;To show the shortcomings of using &lt;code&gt;geom_smooth()&lt;/code&gt; and present a viable alternative, we’ll be using ultrasound tongue imaging data from one speaker (me). This dataset includes tongue contours from within the closure of the conosonants /t, d/ preceeded by /a, o, u/. The dataset looks like this (some columns dropped):&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;select(tongue_data, rec_date, fan_line, X, Y, word, vowel, c2)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1,239 x 7
##    rec_date            fan_line     X     Y word  vowel c2   
##    &amp;lt;chr&amp;gt;                  &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;
##  1 29/11/2016 15:10:52        6  37.4  9.25 pada  a     d    
##  2 29/11/2016 15:21:30        6  38.6 13.1  pada  a     d    
##  3 29/11/2016 15:10:52        7  34.4 10.3  pada  a     d    
##  4 29/11/2016 15:11:03        7  34.3  9.81 pata  a     t    
##  5 29/11/2016 15:11:14        7  34.6 11.0  podo  o     d    
##  6 29/11/2016 15:13:39        7  34.3  9.65 pada  a     d    
##  7 29/11/2016 15:16:05        7  34.8 11.5  pada  a     d    
##  8 29/11/2016 15:17:07        7  34.5 10.5  putu  u     t    
##  9 29/11/2016 15:19:45        7  34.3  9.64 putu  u     t    
## 10 29/11/2016 15:21:30        7  35.4 13.8  pada  a     d    
## # … with 1,229 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;rec_date&lt;/code&gt; is the date and time of recording. Each observed tongue contour has a unique &lt;code&gt;rec_date&lt;/code&gt; (this will come in handy later). &lt;code&gt;fan_line&lt;/code&gt; is the number of the line in the fan coordinate system used by Articulate Assistant Advanced (which I used to record the data). &lt;code&gt;X&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt; are the horizontal and vertical position of each point on the contour. The unit is millimeters. &lt;code&gt;word&lt;/code&gt;, &lt;code&gt;vowel&lt;/code&gt; and &lt;code&gt;c2&lt;/code&gt; are self-explanatory.&lt;/p&gt;
&lt;p&gt;Let’s start by plotting the smoothed contours by vowel and consonant.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tongue_data %&amp;gt;%
  ggplot(aes(X, Y)) +
  geom_smooth(aes(colour = vowel), method = &amp;quot;loess&amp;quot;) +
  coord_fixed() +
  facet_grid(c2 ~ vowel) +
  theme(legend.position = &amp;quot;none&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://stefanocoretta.github.io/post/2018-08-23-plotting-tongue-contours-with-ggplot2_files/figure-html/smooth-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;We can immediately notice that with /u/ there is something odd going on. That does not look like a tongue surface (maybe that of a chameleon! Definitely not one of a ‘hooman’.) The smooths for /a/ and /o/ seem quite standard.&lt;/p&gt;
&lt;p&gt;To see what is going on, let’s plot now also the individual points as recorded in the data, whith a superimoposed smooth, for comparison.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tongue_data %&amp;gt;%
  ggplot(aes(X, Y)) +
  geom_point(alpha = 0.1) +
  geom_smooth(aes(colour = vowel), method = &amp;quot;loess&amp;quot;) +
  coord_fixed() +
  facet_grid(c2 ~ vowel) +
  theme(legend.position = &amp;quot;none&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://stefanocoretta.github.io/post/2018-08-23-plotting-tongue-contours-with-ggplot2_files/figure-html/points-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;While the smooths with /a/ and /o/ more or less have a good fit when compared to the points, with /u/ the smooths are really off.&lt;/p&gt;
&lt;p&gt;This happpens because the tongue root (in this particular case) developpes vertically rather than slanted. The smooth isagnostic about the fact that points lying on the same X value but with different Y values belong to different portion of the tongue contour. The result is that smoothing happens across tongue parts.&lt;/p&gt;
&lt;p&gt;An alternative (if you don’t like points) is to use &lt;code&gt;geom_path()&lt;/code&gt; to plot the individual tongue contours as lines. &lt;code&gt;geom_path()&lt;/code&gt; connects points with a line, following the order in which they appear in the dataset. So, before using this geometry, we need to arrange the dataframe such that the points are in the right order (now they are in the wrong order).&lt;/p&gt;
&lt;p&gt;To do so, we can use &lt;code&gt;rec_date&lt;/code&gt; (which identifies the individual contours) and &lt;code&gt;fan_line&lt;/code&gt; which indicates the orders of points (for each contour, there a maximum 42 points/fan lines; NAs have been excluded).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tongue_data &amp;lt;- tongue_data %&amp;gt;%
  arrange(rec_date, fan_line)

tongue_data&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1,239 x 30
##    speaker seconds rec_date prompt label TT_displacement… TT_velocity
##    &amp;lt;chr&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;    &amp;lt;chr&amp;gt;  &amp;lt;chr&amp;gt;            &amp;lt;dbl&amp;gt;       &amp;lt;dbl&amp;gt;
##  1 it01       1.11 29/11/2… Dico … max_…             77.4       -7.18
##  2 it01       1.11 29/11/2… Dico … max_…             77.4       -7.18
##  3 it01       1.11 29/11/2… Dico … max_…             77.4       -7.18
##  4 it01       1.11 29/11/2… Dico … max_…             77.4       -7.18
##  5 it01       1.11 29/11/2… Dico … max_…             77.4       -7.18
##  6 it01       1.11 29/11/2… Dico … max_…             77.4       -7.18
##  7 it01       1.11 29/11/2… Dico … max_…             77.4       -7.18
##  8 it01       1.11 29/11/2… Dico … max_…             77.4       -7.18
##  9 it01       1.11 29/11/2… Dico … max_…             77.4       -7.18
## 10 it01       1.11 29/11/2… Dico … max_…             77.4       -7.18
## # … with 1,229 more rows, and 23 more variables: TT_velocity_abs &amp;lt;dbl&amp;gt;,
## #   TD_displacement_sm &amp;lt;dbl&amp;gt;, TD_velocity &amp;lt;dbl&amp;gt;, TD_velocity_abs &amp;lt;dbl&amp;gt;,
## #   TR_displacement_sm &amp;lt;dbl&amp;gt;, TR_velocity &amp;lt;dbl&amp;gt;, TR_velocity_abs &amp;lt;dbl&amp;gt;,
## #   fan_line &amp;lt;int&amp;gt;, X &amp;lt;dbl&amp;gt;, Y &amp;lt;dbl&amp;gt;, word &amp;lt;chr&amp;gt;, language &amp;lt;chr&amp;gt;, sex &amp;lt;chr&amp;gt;,
## #   item &amp;lt;int&amp;gt;, ipa &amp;lt;chr&amp;gt;, c1 &amp;lt;chr&amp;gt;, c1_phonation &amp;lt;chr&amp;gt;, vowel &amp;lt;chr&amp;gt;,
## #   anteropost &amp;lt;chr&amp;gt;, height &amp;lt;chr&amp;gt;, c2 &amp;lt;chr&amp;gt;, c2_phonation &amp;lt;chr&amp;gt;,
## #   c2_place &amp;lt;chr&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can now use &lt;code&gt;geom_path()&lt;/code&gt;. The argument &lt;code&gt;group = rec_date&lt;/code&gt; ensures that individual lines are plotted (without it, the last point of one contour is connected with the first of the contour following in the dataset).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tongue_data %&amp;gt;%
  ggplot(aes(X, Y)) +
  geom_path(aes(group = rec_date, colour = vowel), alpha = 0.5) +
  coord_fixed() +
  facet_grid(c2 ~ vowel) +
  theme(legend.position = &amp;quot;none&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://stefanocoretta.github.io/post/2018-08-23-plotting-tongue-contours-with-ggplot2_files/figure-html/path-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The tongue root in /u/ is now properly rendered.&lt;/p&gt;
&lt;p&gt;But what fif you want to plot a single contour (possibly with confidence intervals) for each of the 6 panels in the previous figure, rather than all the contours?&lt;/p&gt;
&lt;p&gt;An option is to plot an average contour (litterally, the aveages of X and Y). We can easily do that by grouping the data by &lt;code&gt;fan_line&lt;/code&gt; and then &lt;code&gt;summarise()&lt;/code&gt; it. Plotting can then be done with &lt;code&gt;geom_path()&lt;/code&gt; and &lt;code&gt;geom_polygon()&lt;/code&gt;. All together, the code looks like this.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;xy_mean &amp;lt;- tongue_data %&amp;gt;%
  group_by(fan_line, vowel, c2) %&amp;gt;%
  summarise(
    X_mean = mean(X, na.rm = TRUE),
    Y_mean = mean(Y, na.rm = TRUE)
  )

xy_ci &amp;lt;- tongue_data %&amp;gt;%
  group_by(fan_line, vowel, c2) %&amp;gt;%
  summarise(
    X_CI_low = t.test(X)$conf.int[1],
    X_CI_up = t.test(X)$conf.int[2],
    Y_CI_low = t.test(Y)$conf.int[1],
    Y_CI_up = t.test(Y)$conf.int[2]
  )

ci_upper &amp;lt;- xy_ci %&amp;gt;%
  dplyr::select(-X_CI_low, -Y_CI_low) %&amp;gt;%
  dplyr::rename(
    CI_X = X_CI_up,
    CI_Y = Y_CI_up
  )

ci_lower &amp;lt;- xy_ci %&amp;gt;%
  dplyr::select(-X_CI_up, -Y_CI_up) %&amp;gt;%
  dplyr::arrange(dplyr::desc(fan_line)) %&amp;gt;%
  dplyr::rename(
    CI_X = X_CI_low,
    CI_Y = Y_CI_low
  )

ci &amp;lt;- rbind(ci_upper, ci_lower)

ggplot(xy_mean, aes(X_mean, Y_mean)) +
  geom_polygon(data = ci, aes(x = CI_X, y = CI_Y), alpha = 0.2) +
  geom_path(aes(X_mean, Y_mean, colour = vowel)) +
  facet_grid(c2 ~ vowel) +
  coord_fixed() +
  theme(legend.position = &amp;quot;none&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://stefanocoretta.github.io/post/2018-08-23-plotting-tongue-contours-with-ggplot2_files/figure-html/mean-path-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
